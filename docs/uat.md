# crawlrs - 用户验收测试文档 (UAT)

## 版本信息
- **文档版本**: v2.0.0
- **测试周期**: Week 11-12
- **最近更新**: 2024-12-10

---

## 1. 验收测试概述

### 1.1 测试目标
- 验证系统功能符合 PRD 要求
- 验证系统性能达到 SLO 指标
- 验证系统在生产环境下的稳定性
- 验证部署流程的可行性

### 1.2 测试范围
- ✅ 核心功能（Scrape/Crawl/Extract）
- ✅ 并发控制与限流
- ✅ 错误处理与恢复
- ✅ 监控与告警
- ✅ 部署与运维

### 1.3 验收标准
- **通过率**: ≥ 95%（关键场景 100%）
- **性能指标**: 满足 PRD 第 8 节要求
- **稳定性**: 7×24 小时运行无崩溃

---

## 2. 功能验收测试

### 2.1 搜索功能（Search）

#### UAT-001: 基础搜索
**测试场景**: 用户执行简单搜索查询

**测试步骤**:
1. 发送 POST /v1/search 请求
   ```json
   {
     "query": "rust programming",
     "sources": ["web"],
     "limit": 10
   }
   ```
2. 验证响应结构
3. 检查返回结果数量

**预期结果**:
- 状态码: 200
- 响应包含 `data.web` 数组
- 结果数量 ≤ 10
- 每个结果包含 `title`, `url`, `description`

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-002: 搜索 + 异步抓取
**测试场景**: 搜索后异步回填内容

**测试步骤**:
1. 发送请求（`async_scraping: true`）
2. 立即获取 `scrape_ids`
3. 轮询 GET /v1/scrape/:id 查询状态
4. 等待所有任务完成

**预期结果**:
- 立即返回任务 ID
- 5 分钟内所有任务完成
- Webhook 正确回调（如配置）

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 2.2 抓取功能（Scrape）

#### UAT-003: 单页面抓取
**测试场景**: 抓取单个静态页面

**测试步骤**:
1. POST /v1/scrape
   ```json
   {
     "url": "https://example.com",
     "formats": ["markdown", "html"]
   }
   ```
2. 验证响应内容
3. 检查元数据

**预期结果**:
- Markdown 内容正确转换
- HTML 结构完整
- metadata.status_code = 200
- 响应时间 < 5 秒

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-004: JavaScript 渲染页面
**测试场景**: 抓取 SPA 应用

**测试步骤**:
1. 抓取 React/Vue 应用页面
2. 验证动态内容是否被捕获

**预期结果**:
- 自动选择 Playwright 引擎
- 动态渲染内容存在于响应中
- 响应时间 < 30 秒

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-005: 页面截图
**测试场景**: 生成页面截图

**测试步骤**:
1. POST /v1/scrape
   ```json
   {
     "url": "https://example.com",
     "formats": ["screenshot"]
   }
   ```
2. 验证截图数据

**预期结果**:
- 返回 Base64 编码的图片
- 图片尺寸 > 0
- 文件类型为 PNG/JPEG

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 2.3 爬取功能（Crawl）

#### UAT-006: 全站爬取
**测试场景**: 爬取完整站点

**测试步骤**:
1. POST /v1/crawl
   ```json
   {
     "url": "https://example.com",
     "crawler_options": {
       "max_depth": 2,
       "limit": 50
     }
   }
   ```
2. 获取爬取 ID
3. 轮询状态直到完成
4. 分页获取结果

**预期结果**:
- 状态最终变为 `completed`
- 爬取页面数 ≤ 50
- 未超过 max_depth
- 去重正确（无重复 URL）

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-007: 路径过滤
**测试场景**: 使用 include/exclude 规则

**测试步骤**:
1. 配置 `include_paths: ["/blog/*"]`
2. 配置 `exclude_paths: ["/admin/*"]`
3. 执行爬取

**预期结果**:
- 只爬取 `/blog/` 下的页面
- 跳过 `/admin/` 路径
- 日志包含跳过记录

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-008: Robots.txt 遵守
**测试场景**: 验证 robots.txt 规则生效

**测试步骤**:
1. 选择有 robots.txt 的站点
2. 查看 Disallow 规则
3. 验证这些路径是否被跳过

**预期结果**:
- 不爬取 Disallow 的路径
- 遵守 Crawl-delay
- Redis 缓存 robots.txt

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-009: 爬取取消
**测试场景**: 取消正在进行的爬取

**测试步骤**:
1. 启动大规模爬取（limit: 10000）
2. 等待 10 秒
3. DELETE /v1/crawl/:id
4. 验证状态

**预期结果**:
- 状态变为 `cancelled`
- 停止生成新任务
- 已完成任务保留

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 2.4 提取功能（Extract）

#### UAT-010: 结构化提取
**测试场景**: 使用 LLM 提取数据

**测试步骤**:
1. POST /v1/extract
   ```json
   {
     "urls": ["https://example.com/product"],
     "prompt": "Extract product name, price, and availability"
   }
   ```
2. 等待处理完成
3. 验证提取结果

**预期结果**:
- 返回结构化 JSON
- 字段符合 prompt 要求
- tokens_used > 0
- credits_used 符合计费规则 (10 Credits/1k tokens)

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

## 3. 并发与限流验收

### 3.1 速率限制

#### UAT-011: 速率限制生效
**测试场景**: 超过 RPM 限制

**测试步骤**:
1. 使用免费版 API Key（100 RPM）
2. 1 分钟内发送 101 个请求
3. 记录响应状态码

**预期结果**:
- 前 100 个请求成功
- 第 101 个请求返回 429
- 响应包含 `Retry-After` 头

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 3.2 团队并发限制

#### UAT-012: 并发槽位用尽
**测试场景**: 超过团队并发限制

**测试步骤**:
1. 使用免费版账户（5 并发）
2. 并发提交 6 个爬取任务
3. 查看第 6 个任务状态

**预期结果**:
- 前 5 个任务立即处理
- 第 6 个任务进入 backlog
- 释放信号量后第 6 个任务开始处理

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

## 4. 错误处理验收

### 4.1 网络异常

#### UAT-013: 超时处理
**测试场景**: 目标站点响应慢

**测试步骤**:
1. 抓取模拟慢速站点（响应 60 秒）
2. 设置 timeout: 10

**预期结果**:
- 10 秒后返回超时错误
- 错误信息清晰
- 任务标记为 `failed`
- 自动重试（如配置）

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-014: SSRF 防护
**测试场景**: 尝试访问内网地址

**测试步骤**:
1. POST /v1/scrape
   ```json
   {
     "url": "http://192.168.1.1"
   }
   ```

**预期结果**:
- 立即返回错误（不建立连接）
- 错误码: 400
- 错误消息: "SSRF detected"

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 4.2 引擎降级

#### UAT-015: 断路器触发
**测试场景**: 引擎连续失败

**测试步骤**:
1. 模拟 Fetch 引擎连续 5 次失败
2. 发送新请求
3. 查看日志

**预期结果**:
- 断路器开启
- 自动降级到 Playwright
- 30 秒后半开尝试恢复

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

## 5. Webhook 验收

### 5.1 成功回调

#### UAT-016: 任务完成通知
**测试场景**: 爬取完成后触发 Webhook

**测试步骤**:
1. 配置 webhook_url
2. 启动爬取任务
3. 等待完成
4. 验证 Webhook 服务器收到请求

**预期结果**:
- 收到 POST 请求
- 包含正确的签名头
- payload 包含任务 ID 和状态

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 5.2 失败重试

#### UAT-017: Webhook 投递重试
**测试场景**: Webhook 端点返回 500

**测试步骤**:
1. 配置返回 500 的 Webhook 端点
2. 触发事件
3. 查看 webhook_events 表

**预期结果**:
- retry_count 逐渐增加
- 使用指数退避（1s, 2s, 4s, 8s, 16s）
- 5 次失败后标记为 `dead`

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

## 6. 性能验收测试

### 6.1 吞吐量测试

#### UAT-018: API 吞吐量
**测试场景**: 高并发请求

**测试工具**: K6

**测试脚本**:
```javascript
export const options = {
  vus: 500,
  duration: '5m',
};
```

**预期结果**:
- 吞吐量 > 10000 RPS (PRD 目标)
- P95 延迟 < 50ms (PRD 目标)
- P99 延迟 < 200ms (PRD 目标)
- 错误率 < 0.1%

**实际结果**: 
- 吞吐量: _____ RPS
- P95 延迟: _____ ms
- P99 延迟: _____ ms
- 错误率: _____ %
- [ ] 通过 / [ ] 失败

---

### 6.2 Worker 处理速度

#### UAT-019: 任务处理速率
**测试场景**: 队列积压消费

**测试步骤**:
1. 创建 100,000 个任务
2. 启动 10 个 Worker
3. 监控消费速度

**预期结果**:
- 处理速度 > 1000 tasks/min
- 无内存泄漏
- 无死锁

**实际结果**: 
- 处理速度: _____ tasks/min
- 内存增长: _____ MB/hour
- [ ] 通过 / [ ] 失败

---

### 6.3 数据库性能

#### UAT-020: 查询性能
**测试场景**: 高并发数据库查询

**测试步骤**:
1. 100 个并发 Worker
2. 每秒执行 1000 次 `acquire_next()`
3. 监控查询时间

**预期结果**:
- P95 查询时间 < 10ms
- 无慢查询（> 50ms）
- 连接池无耗尽

**实际结果**: 
- P95 查询: _____ ms
- 慢查询数: _____
- [ ] 通过 / [ ] 失败

---

## 7. 部署验收测试

### 7.1 单机部署

#### UAT-021: Docker Compose 部署
**测试场景**: 单机环境部署

**测试步骤**:
1. 执行 `docker-compose up -d`
2. 访问 http://localhost:8080/health
3. 执行一次抓取任务

**预期结果**:
- 所有容器启动成功
- 健康检查通过
- 任务正常处理

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

### 7.2 集群部署

#### UAT-022: Kubernetes 部署
**测试场景**: 生产环境集群部署

**测试步骤**:
1. `helm install crawlrs ./chart`
2. 验证所有 Pod 运行
3. 测试负载均衡
4. 测试 HPA 扩缩容

**预期结果**:
- 所有 Pod 状态 Running
- 负载均衡正常
- CPU > 70% 时自动扩容
- 流量降低时自动缩容

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

#### UAT-023: 滚动更新
**测试场景**: 零停机更新

**测试步骤**:
1. 启动压力测试（1000 VU）
2. 执行 `helm upgrade`
3. 监控错误率

**预期结果**:
- 更新过程中错误率 < 0.1%
- 无连接中断
- 更新完成后所有 Pod 为新版本

**实际结果**: 
- [ ] 通过 / [ ] 失败
- **备注**: _______________

---

## 8. 监控验收测试

### 8.1 日志

#### UAT-024: 日志格式 ✅
**测试场景**: 验证日志输出

**测试步骤**:
1. 触发各类操作
2. 查看日志输出
3. 验证 trace_id 可追踪

**预期结果**:
- 日志为 JSON 格式
- 包含 timestamp/level/message/trace_id
- 可通过 trace_id 追踪完整请求链路

**实际结果**: 
- [x] 通过 / [ ] 失败
- **备注**: 已实现结构化JSON日志输出，包含时间戳、级别和消息

---

### 8.2 指标

#### UAT-025: Prometheus 指标 ✅
**测试场景**: 验证指标采集

**测试步骤**:
1. 访问 /metrics 端点
2. 在 Prometheus 中查询指标
3. 在 Grafana 中查看仪表盘

**预期结果**:
- /metrics 返回 Prometheus 格式
- 所有自定义指标存在
- Grafana 仪表盘正常显示

**实际结果**: 
- [x] 通过 / [ ] 失败
- **备注**: 已实现Prometheus指标采集和/metrics端点

---

### 8.3 告警

#### UAT-026: 告警触发 ⏳
**测试场景**: 模拟故障触发告警

**测试步骤**:
1. 停止 Postgres 容器
2. 等待 5 分钟
3. 验证告警

**预期结果**:
- 收到告警通知（邮件/Slack）
- 告警级别正确（P0-Critical）
- 告警信息包含故障详情

**实际结果**: 
- [ ] 通过 / [x] 失败
- **备注**: 未实现完整的告警通知机制

---

## 9. 稳定性验收测试

### 9.1 长时间运行

#### UAT-027: 7×24 小时测试
**测试场景**: 持续负载运行

**测试步骤**:
1. 启动 200 VU 压力测试
2. 持续运行 168 小时（7 天）
3. 监控系统状态

**预期结果**:
- 无崩溃或重启
- 内存无持续增长（< 10% 增长）
- 错误率 < 0.5%
- 平均响应时间稳定

**实际结果**: 
- 运行时长: _____ hours
- 崩溃次数: _____
- 内存增长: _____ %
- 平均错误率: _____ %
- [ ] 通过 / [ ] 失败

---

## 10. 安全验收测试

### 10.1 认证授权

#### UAT-028: 无效 API Key
**测试场景**: 使用无效凭证

**测试步骤**:
1. 发送请求不带 Authorization 头
2. 发送请求带无效 API Key

**预期结果**:
- 返回 401 Unauthorized
- 不泄露敏感信息

**实际结果**: 
- [ ] 通过 / [ ] 失败

---

### 10.2 数据隔离

#### UAT-029: 团队数据隔离
**测试场景**: 验证多租户隔离

**测试步骤**:
1. 创建 Team A 的任务
2. 使用 Team B 的 API Key 查询
3. 验证无法访问

**预期结果**:
- 返回 403 Forbidden
- Team A 数据不可见

**实际结果**: 
- [ ] 通过 / [ ] 失败

---

## 11. 文档验收

### 11.1 API 文档

#### UAT-030: API 文档完整性
**测试内容**:
- [ ] 所有端点有文档
- [ ] 请求/响应示例正确
- [ ] 错误码完整
- [ ] 认证方式说明清晰

---

### 11.2 运维文档

#### UAT-031: 运维手册完整性
**测试内容**:
- [ ] 部署流程清晰
- [ ] 故障排查指南完整
- [ ] 回滚步骤明确
- [ ] 监控指标说明

---

## 12. 验收总结

### 12.1 测试统计

| 类别 | 总数 | 通过 | 失败 | 通过率 |
|------|------|------|------|--------|
| 功能测试 | 15 | ___ | ___ | ___% |
| 并发测试 | 2 | ___ | ___ | ___% |
| 错误处理 | 3 | ___ | ___ | ___% |
| Webhook | 2 | ___ | ___ | ___% |
| 性能测试 | 3 | ___ | ___ | ___% |
| 部署测试 | 3 | ___ | ___ | ___% |
| 监控测试 | 3 | ___ | ___ | ___% |
| 稳定性测试 | 1 | ___ | ___ | ___% |
| 安全测试 | 2 | ___ | ___ | ___% |
| 文档验收 | 2 | ___ | ___ | ___% |
| **总计** | **36** | ___ | ___ | ___% |

### 12.2 风险评估

**高风险问题（阻塞发布）**:
- [ ] 无

**中风险问题（需要修复）**:
- [ ] 待补充

**低风险问题（可延后）**:
- [ ] 待补充

### 12.3 验收结论

**结论**: [ ] 通过验收 / [ ] 不通过验收

**签字**:
- 产品经理: _______________  日期: _______________
- 技术负责人: _______________  日期: _______________
- QA 负责人: _______________  日期: _______________

---

## 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| v2.0.0 | 2024-12-10 | 初始验收文档 | QA 团队 |